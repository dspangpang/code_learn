# 本文是在编程过程中对一些问题的深入研究

## 从Eigen向量化谈内存对齐

[文章来源](https://zhuanlan.zhihu.com/p/93824687)

### 向量化运算

* 向量化运算就是用SSE、AVX等SIMD（Single Instruction Multiple Data）指令集，实现一条指令对多个操作数的运算，从而提高代码的吞吐量，实现加速效果。SSE是一个系列，包括从最初的SSE到最新的SSE4.2，支持同时操作16 bytes的数据，即4个float或者2个double。AVX也是一个系列，它是SSE的升级版，支持同时操作32 bytes的数据，即8个float或者4个double。

* 但向量化运算是有前提的，那就是内存对齐。SSE的操作数，必须16 bytes对齐，而AVX的操作数，必须32 bytes对齐。也就是说，如果我们有4个float数，必须把它们放在连续的且首地址为16的倍数的内存空间中，才能调用SSE的指令进行运算。

### 程序设计的内存对齐

不同的对象创建方式不同内存对齐的方式也不同。

* 直接声明的对象是存储在栈上的，其内存地址由编译器在编译时确定，因此预编译指令会生效。
* 但用new动态创建的对象则存储在堆中，其地址在运行时确定。C++的运行时库并不会关心预编译指令声明的对齐方式，我们需要更强有力的手段来确保内存对齐。(重写```operator new```这个函数)
* 如果设计的类都需要涉及动态创建并且需要内存对齐的话，需要类库的作者提供的```ALIGNED_OPERATOR_NEW```之类的宏定义去保证内存对齐。
* 现代编译器64位系统默认16位对齐，32位系统8位对齐。
